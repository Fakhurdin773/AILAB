{
	"testSnippet": {
	  "prefix": "test",
	  "body": ["print('Hello, Snippet!')"],
	  "description": "Test snippet"
	},
	"bfs": {
	  "prefix": "bfs",
	  "body": [
		"class GoalBasedAgent:",
		"    def __init__(self, goal):",
		"        self.goal = goal",
		"",
		"    def formulate_goal(self, percept):",
		"        if percept == self.goal:",
		"            return \"Goal reached\"",
		"        return \"Searching\"",
		"",
		"    def bfs_search(self, graph, start, goal):",
		"        visited = []",
		"        queue = []",
		"        visited.append(start)",
		"        queue.append(start)",
		"",
		"        while queue:",
		"            node = queue.pop(0)",
		"            print(f\"Visiting: {node}\")",
		"            if node == goal:",
		"                return f\"Goal {goal} found!\"",
		"            for neighbour in graph.get(node, []):",
		"                if neighbour not in visited:",
		"                    visited.append(neighbour)",
		"                    queue.append(neighbour)",
		"",
		"        return \"Goal not found\"",
		"",
		"    def act(self, percept, graph):",
		"        goal_status = self.formulate_goal(percept)",
		"        if goal_status == \"Goal reached\":",
		"            return f\"Goal {self.goal} found!\"",
		"        else:",
		"            return self.bfs_search(graph, percept, self.goal)",
		"",
		"class Environment:",
		"    def __init__(self, graph):",
		"        self.graph = graph",
		"",
		"    def get_percept(self, node):",
		"        return node",
		"",
		"def run_agent(agent, environment, start_node):",
		"    percept = environment.get_percept(start_node)",
		"    action = agent.act(percept, environment.graph)",
		"    print(action)",
		"",
		"tree = {",
		"    'A': ['B', 'C'],",
		"    'B': ['D', 'E'],",
		"    'C': ['F', 'G'],",
		"    'D': ['H'],",
		"    'E': [],",
		"    'F': ['I'],",
		"    'G': [],",
		"    'H': [],",
		"    'I': []",
		"}",
		"",
		"start_node = 'A'",
		"goal_node = 'I'",
		"",
		"agent = GoalBasedAgent(goal_node)",
		"environment = Environment(tree)",
		"",
		"run_agent(agent, environment, start_node)"
	  ],
	  "description": "Breadth-First Search (BFS) Implementation"
	},
"dfs2": {
  "prefix": "ddfs",
  "body": [
    "",
    "from queue import *",
    "graph = {",
    "    'S': ['A', 'B'],",
    "    'A': ['C', 'D'],",
    "    'B': ['Z', 'K'],",
    "    'C': ['M', 'O'],",
    "    'D': ['G', 'H'],",
    "    'Z': ['K'],",
    "    'K': ['G', 'H'],",
    "    'M': ['O'],",
    "    'O': [],",
    "    'G': ['H'],",
    "    'H': []",
    "}",
    "",
    "def dfs(graph , src , goal):",
    "    vis = []",
    "    lq = LifoQueue()",
    "    lq.put(src)",
    "    tarversal_cost = 0",
    "",
    "    while lq:",
    "        node = lq.get()",
    "        tarversal_cost += 1",
    "        print(node)",
    "        if(node == goal):",
    "            break",
    "        ",
    "        for child in graph[node]:",
    "            if child not in vis:",
    "                vis.append(child)",
    "                lq.put(child)",
    "    ",
    "    print(f\"Total Traversal Cost: {tarversal_cost}\")",
    "",
    "",
    "def bfs(graph , src , goal):",
    "    lq = Queue()",
    "    lq.put(src)",
    "    tarversal_cost = 0",
    "",
    "    while lq:",
    "        node = lq.get()",
    "        tarversal_cost += 1",
    "        print(node)",
    "        if(node == goal):",
    "            break",
    "        ",
    "        for child in graph[node]:",
    "                lq.put(child)",
    "    ",
    "    print(f\"Total Traversal Cost: {tarversal_cost}\")",
    "",
    "bfs(graph, 'S', 'H')",
    "",
    "  "
  ],
  "description": ""
},
"UUCS": {
  "prefix": "UCS2",
  "body": [
    "from queue import PriorityQueue",
    "",
    "",
    "graph = {",
    "    0: [(2, 1), (5, 3)],",
    "    1: [(1, 6)],",
    "    3: [(5, 1), (6, 6), (2, 4)],",
    "    4: [(4, 2), (3, 5)],",
    "    2: [(4, 1)],",
    "    5: [(6, 2), (3, 6)],",
    "    6: [(7, 4)]",
    "}",
    "",
    "",
    "def UCS(graph , src , goal):",
    "",
    "    pq = PriorityQueue()",
    "    vis = set()",
    "    pq.put((0,src))",
    "",
    "    while pq:",
    "",
    "        cost , node = pq.get()",
    "",
    "        if node in vis:",
    "            continue",
    "        ",
    "        print(f\"Visiting: {node}, Cost: {cost}\")",
    "        vis.add(node)",
    "",
    "        if node == goal:",
    "            print(f\"Goal Found with cost: {cost}\")",
    "            break",
    "        ",
    "        for x , y in graph[node]:",
    "            if y not in vis:",
    "                # print(\"hello\")",
    "                pq.put((x + cost , y))",
    "    ",
    "    return float('inf')",
    "",
    "",
    "res = UCS(graph , 0 , 5)",
    "",
    ""
  ],
  "description": ""
},
"": {
  "prefix": "GBFS2",
  "body": [
    "from queue import PriorityQueue",
    "h = {",
    "    \"A\": 12,",
    "    \"B\": 4,",
    "    \"C\": 7,",
    "    \"D\": 3,",
    "    \"E\": 8,",
    "    \"F\": 2,",
    "    \"H\": 4,",
    "    \"I\": 9,",
    "    \"S\": 13,",
    "    \"G\": 0,",
    "}",
    "",
    "graph = {",
    "    \"S\": [(3, \"A\"), (2, \"B\")],",
    "    \"A\": [(4, \"C\"), (1, \"D\")],",
    "    \"B\": [(3, \"E\"), (1, \"F\")],",
    "    \"C\": [],",
    "    \"D\": [],",
    "    \"E\": [(5, \"H\")],",
    "    \"F\": [(2, \"I\"), (3, \"G\")],",
    "    \"H\": [],",
    "    \"I\": [],",
    "    \"G\": [],",
    "}",
    "",
    "",
    "",
    "def GBFS(graph , h , start , goal):",
    "    pq = PriorityQueue()",
    "    vis = set()",
    "",
    "    pq.put((h[start], start ,0))",
    "    total_cost = 0",
    "    while pq:",
    "",
    "        cost , node , cost1 = pq.get()",
    "",
    "        if node in vis:",
    "            continue",
    "        ",
    "        vis.add(node)",
    "        total_cost += cost1",
    "        if node == goal:",
    "            print(f\"Goal Found with cost: {total_cost}\")",
    "            return",
    "",
    "        for x , y in graph[node]:",
    "            if y not in vis:",
    "                pq.put((h[y] , y , x))",
    "",
    "    print(\"Goal not found\")",
    "",
    "",
    "",
    ""
  ],
  "description": ""
},
"astar2": {
  "prefix": "astar2",
  "body": [
    "from queue import PriorityQueue",
    "",
    "h = {",
    "    \"S\": 5,",
    "    \"A\": 3,",
    "    \"B\": 4,",
    "    \"C\": 2,",
    "    \"D\": 6,",
    "    \"G\": 0",
    "}",
    "",
    "graph = {",
    "    \"S\": [(1, \"A\"), (10, \"G\")],",
    "    \"A\": [(2, \"B\"), (1, \"C\")],",
    "    \"B\": [(5, \"D\")],",
    "    \"C\": [(3, \"D\"), (4, \"G\")],",
    "    \"D\": [(4, \"G\")],",
    "    \"G\": []",
    "}",
    "",
    "def Astar(graph, h, start, goal):",
    "    pq = PriorityQueue()",
    "    vis = set()",
    "",
    "",
    "    pq.put((h[start], start, 0)) ",
    "",
    "    while not pq.empty():",
    "        f_cost, node, g_cost = pq.get()",
    "",
    "        if node in vis:",
    "            continue",
    "        ",
    "        vis.add(node)",
    "",
    "        if node == goal:",
    "            print(f\"Goal Found with cost: {g_cost}\")",
    "            return",
    "",
    "        for cost, neighbor in graph[node]:",
    "            if neighbor not in vis:",
    "                new_g_cost = g_cost + cost  ",
    "                new_f_cost = new_g_cost + h[neighbor]  ",
    "                pq.put((new_f_cost, neighbor, new_g_cost))",
    "",
    "    print(\"Goal not found\")",
    "",
    "Astar(graph, h, 'S', 'D')",
    ""
  ],
  "description": ""
},
"Q1": {
  "prefix": "Q1",
  "body": [
    "from queue import PriorityQueue",
    "",
    "space = {",
    "    \"Robot\": [('Room A', 1), ('Room B', 4)],",
    "    \"Room A\": [('Room B', 2), ('Room C', 5), ('Human', 12)],",
    "    \"Room B\": [('Room C', 2)],",
    "    \"Room C\": [('Human', 3)],",
    "    \"Human\": []",
    "}",
    "",
    "h = {",
    "    \"Robot\": 7,",
    "    \"Room A\": 6,",
    "    \"Room B\": 4,",
    "    \"Room C\": 2,",
    "    \"Human\": 0",
    "}",
    "",
    "def Astar(space, start, goal):",
    "    pq = PriorityQueue()",
    "    ",
    "    pq.put((h[start], 0, start, [start]))",
    "    visited = set()",
    "",
    "    while not pq.empty():",
    "        f_cost, g_cost, node, path = pq.get()",
    "",
    "        if node in visited:",
    "            continue",
    "        visited.add(node)",
    "",
    "        if node == goal:",
    "            print(\"Goal Found!\", \" -> \".join(path), g_cost)",
    "            return",
    "",
    "        for neighbor, cost in space[node]:",
    "            if neighbor not in visited:",
    "                new_g_cost = g_cost + cost",
    "                new_f_cost = new_g_cost + h[neighbor]",
    "                new_path = path.copy()",
    "                new_path.append(neighbor)",
    "                pq.put((new_f_cost, new_g_cost, neighbor, new_path))",
    "",
    "    print(\"NOT FOUND\")",
    "",
    "Astar(space, 'Robot', 'Human')",
    ""
  ],
  "description": ""
},
"Q2": {
  "prefix": "Q2",
  "body": [
    "from queue import PriorityQueue",
    "",
    "grid = [",
    "",
    "    [1 , 1 , 1 , 1],",
    "    [1 , 2 , 1 , 2],",
    "    [1 , 2 , 2 , 2],",
    "    [1 , 1 , 1 , 1]",
    "]",
    "",
    "start = (0 , 1)",
    "goal =  (3 , 3)",
    "",
    "h = {} # heuristic ( precalculated )  ",
    "for r in range(4):",
    "    for c in range(4):",
    "        h[(r, c)] = abs(goal[0] - r) + abs(goal[1] - c)",
    "",
    "moves = [(1, 0), (0, -1), (0, 1)]",
    "",
    "def Astar(grid , start , goal):",
    "",
    "    pq = PriorityQueue()",
    "    vis = set()",
    "    pq.put((start , h[start] , 0 , [start]))",
    "",
    "    while pq:",
    "",
    "        node , h_cost , g_cost , path = pq.get()",
    "",
    "        if node in vis:",
    "            continue",
    "        ",
    "        vis.add(node)",
    "",
    "        if node == goal:",
    "            print(f\"[X] Goal Found\" , \"->\".join(map(str , path)) , f\"Cost: {g_cost}\")",
    "            return",
    "",
    "        for move in moves:",
    "            new_node = (node[0] + move[0] , node[1] + move[1])",
    "",
    "            if  0 <= new_node[0] < 4 and 0 <= new_node[1] < 4 and new_node not in vis:",
    "                new_g_cost = g_cost + grid[new_node[0]][new_node[1]]",
    "                new_h_cost = new_g_cost + h[new_node]",
    "                new_path = path + [new_node]",
    "                pq.put((new_node, new_h_cost , new_g_cost , new_path))",
    "",
    "",
    "    print(\"NOT FOUND\")",
    "",
    "",
    "",
    "Astar(grid , start , goal)",
    ""
  ],
  "description": ""
},
"Q3": {
  "prefix": "Q3",
  "body": [
    "from queue import PriorityQueue",
    "",
    "space = [",
    "    [1 , 1 , 1 , 1  , 0 , 0 , 0 , 0],",
    "    [1 , 1 , 1 , 1  , 1 , 0 , 0 , 0],",
    "    [0 , 0 , 1 , 0  , 1 , 1 , 1 , 1],",
    "    [0 , 1 , 1 , 1  , 1 , 1 , 1 , 1],",
    "    [1 , 1 , 1 , 1  , 0 , 1 , 1 , 1]",
    "]",
    "",
    "moves = [(-1, -1), (-1, 1), (1, -1), (1, 1)]",
    "start = (0 , 0)",
    "goal =  (4 , 0)",
    "",
    "h = {}",
    "",
    "for i in range (0 , 5):",
    "    for j in range(0 , 8):",
    "        h[(i , j)] = ((goal[0] - i)//2)**2 + ((goal[1] - j)//2)**2",
    "",
    "def Astar(space , start , goal):",
    "    pq = PriorityQueue()",
    "    vis = set()",
    "    pq.put((h[start], 0, start, [start]))",
    "",
    "    while not pq.empty(): ",
    "        print(\"hello\")",
    "        h_cost , g_cost , node , path = pq.get()",
    "",
    "        if node in vis:",
    "            continue",
    "    ",
    "        vis.add(node)",
    "        ",
    "        if node == goal:",
    "            print(\"Goal Found\" , \"->\".join(map(str, path)) , f\" Cost: {g_cost}\")",
    "            return",
    "",
    "        for move in moves:",
    "            new_node = (move[0] + node[0] , move[1] + node[1])",
    "",
    "            if 0 <= new_node[0] < 5 and 0 <= new_node[1] < 8 and new_node not in vis and space[new_node[0]][new_node[1]] != 0:",
    "                new_g_cost = g_cost + space[new_node[0]][new_node[1]]",
    "                new_h_cost = new_g_cost + h[new_node]",
    "                new_path = path + [new_node]",
    "                pq.put((new_h_cost, new_g_cost, new_node, new_path))",
    "    ",
    "    print(\"NOT FOUND\")",
    "",
    "Astar(space , start , goal)",
    ""
  ],
  "description": ""
},
"HCA2": {
  "prefix": "HCA2",
  "body": [
    "import random",
    "",
    "def fitness(board):",
    "    conflicts = 0",
    "    n = len(board)",
    "    ",
    "    for i in range(n):",
    "        for j in range(i + 1, n):",
    "            if board[i] == board[j]: ",
    "                conflicts += 1",
    "            elif abs(board[i] - board[j]) == abs(i - j): ",
    "                conflicts += 1",
    "    return conflicts",
    "",
    "def get_neighbors(board):",
    "    neighbors = []",
    "    n = len(board)",
    "    ",
    "    for col in range(n):",
    "        for row in range(n):",
    "            if row != board[col]: ",
    "                new_board = board[:]",
    "                new_board[col] = row",
    "                neighbors.append(new_board)",
    "    return neighbors",
    "",
    "def hill_climbing():",
    " ",
    "    n = 4",
    "    board = [random.randint(0, n - 1) for _ in range(n)] ",
    "    for i in board:",
    "        print(i)",
    "    ",
    "    while True:",
    "        current_fitness = fitness(board)",
    "        print(current_fitness , end = ' ')",
    "        ",
    "        if current_fitness == 0:",
    "            return board ",
    "        ",
    "        neighbors = get_neighbors(board)",
    "        for i in neighbors:",
    "            print(i)",
    "        best_neighbor = min(neighbors, key=fitness)",
    "        best_fitness = fitness(best_neighbor)",
    "        ",
    "        if best_fitness >= current_fitness:",
    "            return None ",
    "        ",
    "        board = best_neighbor  ",
    "",
    "for _ in range(1):",
    "    solution = hill_climbing()",
    "    if solution:",
    "        print(\"Solution found:\", solution)",
    "        break",
    "else:",
    "    print(\"No solution found, try again!\")"
  ],
  "description": ""
},
"GA2": {
  "prefix": "GA2",
  "body": [
    "import random as rd",
    "",
    "",
    "weights = [4, 5, 7, 11, 10]  ",
    "values = [20, 45, 23, 11, 9]  ",
    "capacity = 15  ",
    "population_size = 6  ",
    "mutation_rate = 0.1  ",
    "generations = 50",
    "",
    "def gernerate_individual():",
    "    return [rd.choice([0 , 1]) for _ in range(len(weights))]",
    "",
    "def fitness(individual):",
    "    total_weight = sum(individual[i] * weights[i] for i in range(len(weights)))",
    "    total_value = sum(individual[i] * values[i] for i in range(len(values)))",
    "    return total_value if total_weight <= capacity else 0 ",
    "",
    "def Select(population):",
    "    return sorted(population , key = fitness , reverse= True)[:2]",
    "",
    "",
    "def mutate(individual):",
    "    if rd.random() < mutation_rate:",
    "        idx = rd.randint(0, len(weights) - 1)",
    "        individual[idx] = 1 - individual[idx]  ",
    "    return individual",
    "",
    "def crossover(parent1, parent2):",
    "    point = rd.randint(1, len(weights) - 1) ",
    "    return parent1[:point] + parent2[point:]",
    "",
    "population = [gernerate_individual() for _ in range(population_size)]",
    "",
    "",
    "for _ in range(generations):",
    "    population = Select(population)",
    "    new_population = []",
    "",
    "    while len(new_population) < population_size:",
    "            ",
    "            parent1, parent2 = rd.sample(population, 2)",
    "            child = mutate(crossover(parent1, parent2))",
    "            new_population.append(child)",
    "        ",
    "    population = new_population  ",
    "",
    "best_solution = max(population, key=fitness)",
    "print(\"Best Solution:\", best_solution)",
    "print(\"Max Value:\", fitness(best_solution))"
  ],
  "description": ""
},
"JOB": {
  "prefix": "JOB",
  "body": [
    "import random as rd",
    "",
    "# Jobs with (deadline, profit)",
    "jobs = [(2, 50), (1, 30), (2, 40), (1, 10), (3, 70), (2, 20)]  ",
    "max_deadline = max(d for d, p in jobs)  # Find the maximum deadline",
    "population_size = 6",
    "mutation_rate = 0.1",
    "generations = 50",
    "",
    "def generate_individual():",
    "    return rd.sample(range(len(jobs)), len(jobs))  # A random order of job indices",
    "",
    "def fitness(individual):",
    "    schedule = [None] * (max_deadline + 1)  # Time slots for jobs",
    "    total_profit = 0",
    "",
    "    for job_index in individual:",
    "        deadline, profit = jobs[job_index]",
    "        for t in range(deadline, 0, -1):  # Assign to the latest available time slot",
    "            if schedule[t] is None:",
    "                schedule[t] = job_index",
    "                total_profit += profit",
    "                break",
    "",
    "    return total_profit",
    "",
    "def Select(population):",
    "    return sorted(population, key=fitness, reverse=True)[:2]",
    "",
    "def mutate(individual):",
    "    if rd.random() < mutation_rate:",
    "        idx1, idx2 = rd.sample(range(len(jobs)), 2)",
    "        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]  # Swap two jobs",
    "    return individual",
    "",
    "def crossover(parent1, parent2):",
    "    point = rd.randint(1, len(jobs) - 1)",
    "    child = parent1[:point] + [j for j in parent2 if j not in parent1[:point]]",
    "    return child",
    "",
    "population = [generate_individual() for _ in range(population_size)]",
    "",
    "for _ in range(generations):",
    "    population = Select(population)",
    "    new_population = []",
    "",
    "    while len(new_population) < population_size:",
    "        parent1, parent2 = rd.sample(population, 2)",
    "        child = mutate(crossover(parent1, parent2))",
    "        new_population.append(child)",
    "",
    "    population = new_population",
    "",
    "best_solution = max(population, key=fitness)",
    "print(\"Best Job Order:\", [jobs[i] for i in best_solution])",
    "print(\"Max Profit:\", fitness(best_solution))",
    ""
  ],
  "description": ""
},
"Q4": {
  "prefix": "Q4",
  "body": [
    "from queue import *",
    "",
    "grid = [",
    "    ['.', '.', '.', '.', '.', '.', '.', '.', '.'],",
    "    ['.', '.', '.', '.', 'G', '.', '.', '.', '.'],",
    "    ['.', '#', '#', '#', '#', '#', '#', '.', '.'],",
    "    ['.', '#', 'S', '.', '.', '.', '#', '.', '.'],",
    "    ['.', '#', '#', '#', '.', '#', '#', '.', '.'],",
    "    ['.', '.', '.', '.', '.', '.', '.', '.', '.']",
    "]",
    "",
    "",
    "",
    "def dfs(grid , src , goal):",
    "",
    "    lq = LifoQueue()",
    "    lq.put((src))",
    "    vis = set()",
    "    moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]",
    "    rows = len(grid)",
    "    cols = len(grid[0])",
    "    path = []",
    "    count = 0",
    "",
    "    while lq:",
    "        ",
    "        cell = lq.get()",
    "",
    "        if cell in vis:",
    "            continue",
    "        ",
    "        vis.add(cell)",
    "        count += 1",
    "        path.append((cell[0] , cell[1]))",
    "        if grid[cell[0]][cell[1]] == goal:",
    "            print('GOAL FOUND' , '->'.join(map(str , path)), f'Total Nodes Explored: {count}')",
    "        ",
    "",
    "        for move in moves:",
    "            new_x = move[0] + cell[0]",
    "            new_y = move[1] + cell[1]",
    "",
    "            if 0 <= new_x < rows and 0 <= new_y < cols and (new_x,new_y) not in vis and grid[new_x][new_y] != '#':",
    "                lq.put((new_x,new_y))",
    "    ",
    "    print(\"GOAL NOT FOUND\")",
    "",
    "",
    "dfs(grid, (3,2) , 'G')"
  ],
  "description": ""
},


"Q5": {
  "prefix": "Q5",
  "body": [
    "from queue import *",
    "",
    "grid = [",
    "    ['.', '.', '.', '.', '.', '.', '.', '.', '.'],",
    "    ['.', '.', '.', '.', 'G', '.', '.', '.', '.'],",
    "    ['.', '#', '#', '#', '#', '#', '#', '.', '.'],",
    "    ['.', '#', 'S', '.', '.', '.', '#', '.', '.'],",
    "    ['.', '#', '#', '#', '.', '#', '#', '.', '.'],",
    "    ['.', '.', '.', '.', '.', '.', '.', '.', '.']",
    "]",
    "",
    "",
    "",
    "def bfs(grid , src , goal):",
    "",
    "    lq = Queue()",
    "    lq.put((src))",
    "    vis = set()",
    "    moves = [(-1, 0), (0, -1), (0, 1), (1, 0)]",
    "    rows = len(grid)",
    "    cols = len(grid[0])",
    "    path = []",
    "    count = 0",
    "",
    "    while lq:",
    "        ",
    "        cell = lq.get()",
    "",
    "        if cell in vis:",
    "            continue",
    "        ",
    "        vis.add(cell)",
    "        count += 1",
    "        path.append((cell[0] , cell[1]))",
    "        if grid[cell[0]][cell[1]] == goal:",
    "            print('GOAL FOUND' , '->'.join(map(str , path)), f'Total Nodes Explored: {count}')",
    "        ",
    "",
    "        for move in moves:",
    "            new_x = move[0] + cell[0]",
    "            new_y = move[1] + cell[1]",
    "",
    "            if 0 <= new_x < rows and 0 <= new_y < cols and (new_x,new_y) not in vis and grid[new_x][new_y] != '#':",
    "                lq.put((new_x,new_y))",
    "    ",
    "    print(\"GOAL NOT FOUND\")",
    "",
    "",
    "bfs(grid, (3,2) , 'G')"
  ],
  "description": ""
},
"DLS2": {
  "prefix": "DLS2",
  "body": [
    "graph = {",
    "    0: [1, 2],",
    "    1: [3, 4],",
    "    2: [5, 6],",
    "    3: [],",
    "    4: [],",
    "    5: [],",
    "    6: []",
    "}",
    "",
    "def DLS(graph, src, target, maxDepth):",
    "    print(f\"Node: {src} , Depth: {maxDepth} , Target: {target}\")",
    "    if src == target:",
    "        return True",
    "    if maxDepth <= 0:",
    "        return False",
    "",
    "    for neighbor in graph.get(src, []):",
    "        if DLS(graph, neighbor, target, maxDepth - 1):",
    "            return True",
    "    return False",
    "",
    "",
    "def IDFS(graph , src , target, limit):",
    "",
    "    for i in range(0 , limit + 1):",
    "        print(f\"Iteration {i}\")",
    "        if DLS(graph,src,target,i) == True :",
    "            return True",
    "    return False",
    "",
    "# print(DLS(graph,0,6,2))",
    "IDFS(graph,0,3,3)"
  ],
  "description": ""
},
"TSP2": {
  "prefix": "TSP2",
  "body": [
    "from itertools import permutations",
    "",
    "def getTotalVertices(graph):",
    "    vertices = []",
    "    for vertex in graph:",
    "        if vertex not in vertices:",
    "            vertices.append(vertex)",
    "    return len(vertices)",
    "",
    "def travellingSalesmanProblem(graph, s):",
    "    vertex = []",
    "    V = getTotalVertices(graph)",
    "    vertex = [i for i in range(V) if i != s]",
    "    minPathCost = 100000000",
    "    perms = permutations(vertex)",
    "    for permutation in perms:",
    "        path = [str(s)]",
    "        cost = 0",
    "        k = s",
    "        for j in permutation:",
    "            cost += graph[k][j]",
    "            k = j",
    "            path.append(str(j))",
    "        cost += graph[k][s]",
    "        path.append(str(s))",
    "        minPathCost = min(minPathCost, cost)",
    "        minPath = \" -> \".join(path)",
    "    return minPathCost, minPath",
    "",
    "graph = [",
    "    [0, 10, 15, 20],",
    "    [10, 0, 35, 25],",
    "    [15, 35, 0, 30],",
    "    [20, 25, 30, 0]",
    "]",
    "s = 0",
    "cost, path = travellingSalesmanProblem(graph, s)",
    "print(f\"Minimum Path: {path}\")",
    "print(f\"Cost: {cost}\")",
    ""
  ],
  "description": ""
},"TSPKS": {
  "prefix": "TSPHKS",
  "body": [
    "import random",
    "",
    "num_items = 5",
    "weights = [2, 3, 4, 5, 6]  ",
    "values = [3, 4, 5, 8, 9]   ",
    "capacity = 10              ",
    "",
    "def fitness(solution):",
    "    \"\"\"Compute total value of selected items, with penalty for exceeding capacity.\"\"\"",
    "    total_weight = sum(solution[i] * weights[i] for i in range(num_items))",
    "    total_value = sum(solution[i] * values[i] for i in range(num_items))",
    "    ",
    "    if total_weight > capacity:",
    "        return 0  ",
    "    ",
    "    return total_value",
    "",
    "def get_neighbors(solution):",
    "",
    "    neighbors = []",
    "    ",
    "    for i in range(num_items):",
    "        new_solution = solution[:]",
    "        new_solution[i] = 1 - new_solution[i]",
    "        neighbors.append(new_solution)",
    "    ",
    "    return neighbors",
    "",
    "def hill_climbing():",
    "",
    "    current_solution = [random.randint(0, 1) for _ in range(num_items)]",
    "    ",
    "    while True:",
    "        current_fitness = fitness(current_solution)",
    "        print(f\"Current solution: {current_solution}, Value: {current_fitness}\")",
    "        ",
    "        neighbors = get_neighbors(current_solution)",
    "        best_neighbor = max(neighbors, key=fitness)",
    "        best_fitness = fitness(best_neighbor)",
    "        ",
    "        if best_fitness <= current_fitness:  ",
    "            return current_solution, current_fitness",
    "        ",
    "       ",
    "        current_solution = best_neighbor  ",
    "",
    "",
    "solution, max_value = hill_climbing()",
    "print(\"\\nFinal Solution:\", solution)",
    "print(\"Maximum Value Achieved:\", max_value)",
    ""
  ],
  "description": ""
},"TSPHCA": {
  "prefix": "TSPHCA",
  "body": [
    "import random",
    "",
    "# Distance matrix (Example for 5 cities)",
    "distances = [",
    "    [0, 2, 9, 10, 7],",
    "    [2, 0, 6, 4, 3],",
    "    [9, 6, 0, 8, 5],",
    "    [10, 4, 8, 0, 6],",
    "    [7, 3, 5, 6, 0]",
    "]",
    "",
    "num_cities = len(distances)",
    "",
    "def fitness(route):",
    "    \"\"\"Calculate total distance of the given route.\"\"\"",
    "    total_distance = sum(distances[route[i]][route[i + 1]] for i in range(num_cities - 1))",
    "    total_distance += distances[route[-1]][route[0]]  # Return to start",
    "    return total_distance",
    "",
    "def get_neighbors(route):",
    "    \"\"\"Generate neighbors by swapping two cities.\"\"\"",
    "    neighbors = []",
    "    for i in range(num_cities):",
    "        for j in range(i + 1, num_cities):",
    "            new_route = route[:]",
    "            new_route[i], new_route[j] = new_route[j], new_route[i]  # Swap two cities",
    "            neighbors.append(new_route)",
    "    return neighbors",
    "",
    "def hill_climbing():",
    "    \"\"\"Hill climbing algorithm for TSP.\"\"\"",
    "    # Generate a random initial route",
    "    current_route = list(range(num_cities))",
    "    random.shuffle(current_route)",
    "",
    "    while True:",
    "        current_fitness = fitness(current_route)",
    "        print(f\"Current route: {current_route}, Distance: {current_fitness}\")",
    "        ",
    "        # Generate neighbors and find the best one",
    "        neighbors = get_neighbors(current_route)",
    "        best_neighbor = min(neighbors, key=fitness)",
    "        best_fitness = fitness(best_neighbor)",
    "        ",
    "        if best_fitness >= current_fitness:  # No improvement, return solution",
    "            return current_route, current_fitness",
    "        ",
    "        # Move to the best neighbor",
    "        current_route = best_neighbor  ",
    "",
    "# Run the algorithm",
    "solution, min_distance = hill_climbing()",
    "print(\"\\nFinal Route:\", solution)",
    "print(\"Minimum Distance:\", min_distance)",
    ""
  ],
  "description": ""
},"TSPGA": {
  "prefix": "TSPGA",
  "body": [
    "import random as rd",
    "",
    "# Distance matrix (Example for 5 cities)",
    "distances = [",
    "    [0, 2, 9, 10, 7],",
    "    [2, 0, 6, 4, 3],",
    "    [9, 6, 0, 8, 5],",
    "    [10, 4, 8, 0, 6],",
    "    [7, 3, 5, 6, 0]",
    "]",
    "",
    "num_cities = len(distances)",
    "population_size = 6",
    "mutation_rate = 0.1",
    "generations = 50",
    "",
    "def generate_individual():",
    "    route = list(range(num_cities))",
    "    rd.shuffle(route)  # Random initial route",
    "    return route",
    "",
    "def fitness(route):",
    "    \"\"\"Calculate total distance of the given route (lower is better).\"\"\"",
    "    total_distance = sum(distances[route[i]][route[i + 1]] for i in range(num_cities - 1))",
    "    total_distance += distances[route[-1]][route[0]]  # Return to start",
    "    return 1 / total_distance  # Inverse since GA maximizes fitness",
    "",
    "def select(population):",
    "    return sorted(population, key=fitness, reverse=True)[:2]",
    "",
    "def mutate(route):",
    "    \"\"\"Swap mutation: swaps two cities.\"\"\"",
    "    if rd.random() < mutation_rate:",
    "        i, j = rd.sample(range(num_cities), 2)",
    "        route[i], route[j] = route[j], route[i]",
    "    return route",
    "",
    "def crossover(parent1, parent2):",
    "    \"\"\"Partially Mapped Crossover (PMX) for TSP.\"\"\"",
    "    point1, point2 = sorted(rd.sample(range(num_cities), 2))",
    "    child = [-1] * num_cities",
    "    child[point1:point2] = parent1[point1:point2]",
    "",
    "    for city in parent2:",
    "        if city not in child:",
    "            for i in range(num_cities):",
    "                if child[i] == -1:",
    "                    child[i] = city",
    "                    break",
    "    return child",
    "",
    "population = [generate_individual() for _ in range(population_size)]",
    "",
    "for _ in range(generations):",
    "    population = select(population)",
    "    new_population = []",
    "",
    "    while len(new_population) < population_size:",
    "        parent1, parent2 = rd.sample(population, 2)",
    "        child = mutate(crossover(parent1, parent2))",
    "        new_population.append(child)",
    "",
    "    population = new_population  ",
    "",
    "best_solution = max(population, key=fitness)",
    "print(\"\\nBest Route:\", best_solution)",
    "print(\"Minimum Distance:\", 1 / fitness(best_solution))",
    ""
  ],
  "description": ""
},"QueensGA": {
  "prefix": "QueensGA",
  "body": [
    "import random as rd",
    "",
    "num_queens = 4",
    "population_size = 6",
    "mutation_rate = 0.1",
    "generations = 50",
    "",
    "def generate_individual():",
    "    \"\"\"Generate a random board state for 4-Queens.\"\"\"",
    "    return [rd.randint(0, num_queens - 1) for _ in range(num_queens)]  ",
    "",
    "def fitness(board):",
    "    \"\"\"Count non-attacking pairs (higher is better).\"\"\"",
    "    max_pairs = num_queens * (num_queens - 1) // 2",
    "    conflicts = 0",
    "",
    "    for i in range(num_queens):",
    "        for j in range(i + 1, num_queens):",
    "            if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):",
    "                conflicts += 1",
    "",
    "    return max_pairs - conflicts  # Higher value means fewer conflicts",
    "",
    "def select(population):",
    "    return sorted(population, key=fitness, reverse=True)[:2]",
    "",
    "def mutate(board):",
    "    \"\"\"Change the row of one queen randomly.\"\"\"",
    "    if rd.random() < mutation_rate:",
    "        idx = rd.randint(0, num_queens - 1)",
    "        board[idx] = rd.randint(0, num_queens - 1)",
    "    return board",
    "",
    "def crossover(parent1, parent2):",
    "    \"\"\"Single-point crossover.\"\"\"",
    "    point = rd.randint(1, num_queens - 1)  ",
    "    return parent1[:point] + parent2[point:]",
    "",
    "population = [generate_individual() for _ in range(population_size)]",
    "",
    "for _ in range(generations):",
    "    population = select(population)",
    "    new_population = []",
    "",
    "    while len(new_population) < population_size:",
    "        parent1, parent2 = rd.sample(population, 2)",
    "        child = mutate(crossover(parent1, parent2))",
    "        new_population.append(child)",
    "",
    "    population = new_population  ",
    "",
    "best_solution = max(population, key=fitness)",
    "print(\"\\nBest Solution:\", best_solution)",
    "print(\"Fitness (Non-attacking pairs):\", fitness(best_solution))",
    ""
  ],
  "description": ""
},"UtilityBasedAgent2": {
  "prefix": "UtilityBasedAgent2",
  "body": [
    "from queue import LifoQueue",
    "",
    "class Environment:",
    "",
    "    def __init__(self, graph, utilities):",
    "        self.graph = graph",
    "        self.utilities = utilities",
    "",
    "    def get_neighbors(self, node):",
    "      ",
    "        return self.graph.get(node, [])",
    "",
    "    def get_utility(self, node):",
    "      ",
    "        return self.utilities.get(node, float('-inf'))",
    "",
    "",
    "class UtilityBasedAgent:",
    "",
    "    def __init__(self, environment, start, goal):",
    "        self.environment = environment",
    "        self.start = start",
    "        self.goal = goal",
    "",
    "    def dfs_with_utility(self):",
    "       ",
    "        visited = set()",
    "        stack = LifoQueue()",
    "        stack.put((self.start, [self.start], 0))  ",
    "        best_path = None",
    "        best_utility = float('-inf')",
    "        traversal_cost = 0",
    "",
    "        while not stack.empty():",
    "            node, path, utility = stack.get()",
    "",
    "            if node in visited:",
    "                continue",
    "",
    "            visited.add(node)",
    "            traversal_cost += 1",
    "            print(f\"Visited: {node}, Current Utility: {utility}\")",
    "",
    "            if node == self.goal:",
    "                print(f\"ðŸ”¹ Goal '{self.goal}' reached!\")",
    "                print(f\"ðŸ”¹ Path: {' -> '.join(path)}\")",
    "                print(f\"ðŸ”¹ Total Traversal Cost: {traversal_cost}\")",
    "",
    "               ",
    "                if utility > best_utility:",
    "                    best_utility = utility",
    "                    best_path = path",
    "",
    "            # Sort neighbors by highest utility first",
    "            neighbors = sorted(",
    "                self.environment.get_neighbors(node),",
    "                key=lambda x: self.environment.get_utility(x),",
    "                reverse=True  # Higher utility is better",
    "            )",
    "",
    "            for neighbor in neighbors:",
    "                if neighbor not in visited:",
    "                    new_utility = utility + self.environment.get_utility(neighbor)",
    "                    stack.put((neighbor, path + [neighbor], new_utility))",
    "",
    "        if best_path:",
    "            print(f\"\\nðŸ”¹ Best Path Based on Utility: {' -> '.join(best_path)}\")",
    "            print(f\"ðŸ”¹ Best Utility Score: {best_utility}\")",
    "        else:",
    "            print(\"\\nðŸ”¹ Goal Not Found\")",
    "",
    "",
    "# Define the graph environment",
    "graph = {",
    "    'S': ['A', 'B'],",
    "    'A': ['C', 'D'],",
    "    'B': ['Z', 'K'],",
    "    'C': ['M', 'O'],",
    "    'D': ['G', 'H'],",
    "    'Z': ['K'],",
    "    'K': ['G', 'H'],",
    "    'M': ['O'],",
    "    'O': [],",
    "    'G': ['H'],",
    "    'H': []",
    "}",
    "",
    "# Define utility values for each node (higher is better)",
    "utilities = {",
    "    'S': 5, 'A': 4, 'B': 3, 'C': 7, 'D': 6, 'Z': 2, 'K': 5,",
    "    'M': 8, 'O': 9, 'G': 7, 'H': 10  # Goal should have the highest utility",
    "}",
    "",
    "",
    "env = Environment(graph, utilities)",
    "",
    "",
    "agent = UtilityBasedAgent(env, start='S', goal='H')",
    "agent.dfs_with_utility()",
    ""
  ],
  "description": ""
},
"GoalBasedAgent2": {
  "prefix": "GoalBasedAgent2",
  "body": [
    "from queue import LifoQueue",
    "",
    "class Environment:",
    "    ",
    "    def __init__(self, graph):",
    "        self.graph = graph",
    "",
    "    def get_neighbors(self, node):",
    "        ",
    "        return self.graph.get(node, [])",
    "",
    "class GoalBasedAgent:",
    "",
    "    def __init__(self, environment, start, goal):",
    "        self.environment = environment  ",
    "        self.start = start              ",
    "        self.goal = goal                ",
    "",
    "    def dfs(self):",
    "        visited = set()",
    "        stack = LifoQueue()",
    "        stack.put((self.start, [self.start]))  ",
    "        traversal_cost = 0",
    "",
    "        while not stack.empty():",
    "            node, path = stack.get()",
    "            ",
    "            if node in visited:",
    "                continue",
    "",
    "            visited.add(node)",
    "            traversal_cost += 1",
    "            print(node) ",
    "",
    "            if node == self.goal:",
    "                print(f\"Goal '{self.goal}' reached!\")",
    "                print(f\"Path: {' -> '.join(path)}\")",
    "                print(f\"Total Traversal Cost: {traversal_cost}\")",
    "                return ",
    "",
    "            for neighbor in reversed(self.environment.get_neighbors(node)):",
    "                if neighbor not in visited:",
    "                    stack.put((neighbor, path + [neighbor]))",
    "",
    "        print(\"Goal not found.\")",
    "",
    "",
    "graph = {",
    "    'S': ['A', 'B'],",
    "    'A': ['C', 'D'],",
    "    'B': ['Z', 'K'],",
    "    'C': ['M', 'O'],",
    "    'D': ['G', 'H'],",
    "    'Z': ['K'],",
    "    'K': ['G', 'H'],",
    "    'M': ['O'],",
    "    'O': [],",
    "    'G': ['H'],",
    "    'H': []",
    "}",
    "",
    "",
    "env = Environment(graph)",
    "",
    "",
    "agent = GoalBasedAgent(env, start='S', goal='H')",
    "",
    "",
    "agent.dfs()",
    ""
  ],
  "description": ""
},
"Midexam": {
  "prefix": "Midexam",
  "body": [
    "import random",
    "",
    "# Function to evaluate fitness",
    "def fitness(x):",
    "    return x**2 + x",
    "",
    "# Convert binary string to integer",
    "def binary_to_int(binary_str):",
    "    return int(binary_str, 2)",
    "",
    "# Convert integer to binary string (5-bit representation)",
    "def int_to_binary(num):",
    "    return format(num, '05b')",
    "",
    "# Generate initial population",
    "def generate_population(size=6):",
    "    return [int_to_binary(random.randint(0, 31)) for _ in range(size)]",
    "",
    "# Selection based on fitness",
    "def select_parents(population):",
    "    sorted_population = sorted(population, key=lambda x: fitness(binary_to_int(x)), reverse=True)",
    "    return sorted_population[:2]  # Select top 2 individuals",
    "",
    "# Single-point crossover",
    "def crossover(parent1, parent2):",
    "    point = random.randint(1, 4)  # Select crossover point",
    "    child1 = parent1[:point] + parent2[point:]",
    "    child2 = parent2[:point] + parent1[point:]",
    "    return child1, child2",
    "",
    "# Mutation (flip a random bit)",
    "def mutate(binary_str):",
    "    index = random.randint(0, 4)",
    "    mutated = list(binary_str)",
    "    mutated[index] = '0' if mutated[index] == '1' else '1'",
    "    return \"\".join(mutated)",
    "",
    "# Genetic Algorithm",
    "def genetic_algorithm(generations=10, population_size=6):",
    "    population = generate_population(population_size)",
    "    ",
    "    for _ in range(generations):",
    "        parents = select_parents(population)",
    "        offspring = []",
    "        ",
    "        for _ in range(population_size // 2):",
    "            child1, child2 = crossover(parents[0], parents[1])",
    "            offspring.append(mutate(child1))",
    "            offspring.append(mutate(child2))",
    "        ",
    "        population = offspring  # Replace old population",
    "    ",
    "    best_solution = max(population, key=lambda x: fitness(binary_to_int(x)))",
    "    best_x = binary_to_int(best_solution)",
    "    best_value = fitness(best_x)",
    "    ",
    "    return best_x, best_value",
    "",
    "# Run the Genetic Algorithm",
    "best_x, best_value = genetic_algorithm()",
    "print(f\"Best x: {best_x}, Maximum f(x): {best_value}\")",
    ""
  ],
  "description": ""
}
  }
  